#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
using namespace std;

/* ===================== DATA STRUCTURES ===================== */

struct Student {
    int id;
    string name;
    string dept;
    int semester;
    float cgpa;
    int credits;
    int year;
};

struct Node {
    Student data;
    Node* next;
};

/* ===================== LINKED LIST UTILITIES ===================== */

Node* createNode(Student s) {
    Node* n = new Node;
    n->data = s;
    n->next = nullptr;
    return n;
}

void append(Node*& head, Student s) {
    Node* n = createNode(s);
    if (!head) {
        head = n;
        return;
    }
    Node* temp = head;
    while (temp->next) temp = temp->next;
    temp->next = n;
}

Node* copyList(Node* head) {
    Node* newHead = nullptr;
    while (head) {
        append(newHead, head->data);
        head = head->next;
    }
    return newHead;
}

void freeList(Node*& head) {
    while (head) {
        Node* t = head;
        head = head->next;
        delete t;
    }
}

/* ===================== MERGE SORT (LINKED LIST) ===================== */

Node* merge(Node* a, Node* b, bool (*cmp)(Student, Student)) {
    if (!a) return b;
    if (!b) return a;

    if (cmp(a->data, b->data)) {
        a->next = merge(a->next, b, cmp);
        return a;
    } else {
        b->next = merge(a, b->next, cmp);
        return b;
    }
}

void split(Node* source, Node*& front, Node*& back) {
    Node* slow = source;
    Node* fast = source->next;

    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    front = source;
    back = slow->next;
    slow->next = nullptr;
}

void mergeSort(Node*& head, bool (*cmp)(Student, Student)) {
    if (!head || !head->next) return;

    Node* a;
    Node* b;
    split(head, a, b);

    mergeSort(a, cmp);
    mergeSort(b, cmp);

    head = merge(a, b, cmp);
}

/* ===================== BUBBLE SORT ===================== */

void bubbleSort(Node* head, bool (*cmp)(Student, Student)) {
    if (!head) return;
    bool swapped;
    do {
        swapped = false;
        Node* curr = head;
        while (curr->next) {
            if (!cmp(curr->data, curr->next->data)) {
                swap(curr->data, curr->next->data);
                swapped = true;
            }
            curr = curr->next;
        }
    } while (swapped);
}

/* ===================== COMPARATORS ===================== */

bool cmpCGPA(Student a, Student b) {
    if (a.cgpa != b.cgpa) return a.cgpa > b.cgpa;
    return a.credits > b.credits;
}

bool cmpEnrollment(Student a, Student b) {
    if (a.year != b.year) return a.year < b.year;
    return a.id < b.id;
}

bool cmpDept(Student a, Student b) {
    if (a.dept != b.dept) return a.dept < b.dept;
    if (a.semester != b.semester) return a.semester < b.semester;
    return a.cgpa > b.cgpa;
}

bool cmpName(Student a, Student b) {
    return a.name < b.name;
}

/* ===================== FILE OUTPUTS ===================== */

void outputRankedByCGPA(Node* head) {
    ofstream out("ranked_by_cgpa.txt");
    out << "================ STUDENTS RANKED BY CGPA ================\n";
    out << left << setw(5) << "Rank" << setw(8) << "ID"
        << setw(20) << "Name" << setw(6) << "Dept"
        << setw(6) << "Sem" << setw(7) << "CGPA"
        << setw(9) << "Credits" << setw(6) << "Year\n";

    int rank = 1;
    while (head) {
        out << setw(5) << rank++
            << setw(8) << head->data.id
            << setw(20) << head->data.name
            << setw(6) << head->data.dept
            << setw(6) << head->data.semester
            << setw(7) << fixed << setprecision(2) << head->data.cgpa
            << setw(9) << head->data.credits
            << setw(6) << head->data.year << "\n";
        head = head->next;
    }
    out.close();
}

void outputSortedByEnrollment(Node* head) {
    ofstream out("sorted_by_enrollment.txt");
    int currentYear = -1;
    float sum = 0;
    int count = 0;

    while (head) {
        if (head->data.year != currentYear) {
            if (count > 0) {
                out << "Average CGPA: " << sum / count << "\n\n";
            }
            currentYear = head->data.year;
            out << "===== Enrollment Year: " << currentYear << " =====\n";
            sum = 0;
            count = 0;
        }
        out << head->data.id << " "
            << head->data.name << " "
            << head->data.cgpa << "\n";
        sum += head->data.cgpa;
        count++;
        head = head->next;
    }
    if (count > 0)
        out << "Average CGPA: " << sum / count << "\n";

    out.close();
}

void outputDepartmentAnalysis(Node* head) {
    ofstream out("department_analysis.txt");
    string currDept = "";
    int count = 0;
    float sum = 0, maxG = 0, minG = 4.0;
    int credits = 0;

    while (head) {
        if (head->data.dept != currDept) {
            if (count > 0) {
                out << "Students: " << count
                    << "\nAvg CGPA: " << sum / count
                    << "\nHighest: " << maxG
                    << "\nLowest: " << minG
                    << "\nAvg Credits: " << credits / count << "\n\n";
            }
            currDept = head->data.dept;
            out << "===== Department: " << currDept << " =====\n";
            count = 0; sum = 0; maxG = 0; minG = 4.0; credits = 0;
        }
        sum += head->data.cgpa;
        maxG = max(maxG, head->data.cgpa);
        minG = min(minG, head->data.cgpa);
        credits += head->data.credits;
        count++;
        out << head->data.name << " (Sem " << head->data.semester
            << ") CGPA: " << head->data.cgpa << "\n";
        head = head->next;
    }
    out.close();
}

void outputPerformanceTiers(Node* head) {
    ofstream out("performance_tiers.txt");

    const char* tierNames[] = {
        "Elite", "High Achievers", "Good Standing",
        "Satisfactory", "Needs Improvement"
    };

    Node* tiers[5] = {nullptr};

    while (head) {
        float c = head->data.cgpa;
        int idx =
            (c >= 3.7) ? 0 :
            (c >= 3.3) ? 1 :
            (c >= 3.0) ? 2 :
            (c >= 2.5) ? 3 : 4;
        append(tiers[idx], head->data);
        head = head->next;
    }

    for (int i = 0; i < 5; i++) {
        bubbleSort(tiers[i], cmpName);
        out << "===== " << tierNames[i] << " =====\n";
        Node* t = tiers[i];
        int cnt = 0;
        while (t) {
            out << t->data.name << " (" << t->data.cgpa << ")\n";
            cnt++;
            t = t->next;
        }
        out << "Count: " << cnt << "\n\n";
    }
    out.close();
}

/* ===================== MAIN ===================== */

int main() {
    ifstream in("students_data.txt");
    if (!in) {
        cerr << "Input file not found.\n";
        return 1;
    }

    int n;
    in >> n;
    Node* master = nullptr;

    for (int i = 0; i < n; i++) {
        Student s;
        in >> s.id;
        in.ignore();
        getline(in, s.name);
        in >> s.dept >> s.semester >> s.cgpa >> s.credits >> s.year;
        append(master, s);
    }
    in.close();

    Node* cgpaList = copyList(master);
    mergeSort(cgpaList, cmpCGPA);
    outputRankedByCGPA(cgpaList);

    Node* enrollList = copyList(master);
    mergeSort(enrollList, cmpEnrollment);
    outputSortedByEnrollment(enrollList);

    Node* deptList = copyList(master);
    mergeSort(deptList, cmpDept);
    outputDepartmentAnalysis(deptList);

    Node* tierList = copyList(master);
    outputPerformanceTiers(tierList);

    freeList(master);
    freeList(cgpaList);
    freeList(enrollList);
    freeList(deptList);
    freeList(tierList);

    return 0;
}
